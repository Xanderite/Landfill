{"version":3,"sources":["webpack:///landfill.js","webpack:///webpack/bootstrap c9240960ac4a66e8dc56","webpack:///external \"babel-polyfill\"","webpack:///./src/cli.js","webpack:///external \"path\"","webpack:///external \"commander\"","webpack:///external \"semver\"","webpack:///external \"chalk\"","webpack:///external \"dedent-js\"","webpack:///external \"lodash\"","webpack:///./src/lib/configLoader.js","webpack:///external \"mz/fs\"","webpack:///external \"resolve\"","webpack:///external \"child_process\"","webpack:///./src/landfill.js","webpack:///./src/lib/prompt.js","webpack:///external \"readline\"","webpack:///./src/lib/fileCopy.js","webpack:///./src/lib/ncp.js","webpack:///external \"mkdirp\"","webpack:///external \"stream\""],"names":["GLOBAL","require","__dirname","version","module","exports","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_taggedTemplateLiteral","strings","raw","Object","freeze","defineProperties","value","listTemplates","options","_commander2","commands","_configLoader","configLoader","then","ancestry","allTemplates","_loop","rank","ancestor","templates","keys","map","template","_lodash","merge","templateName","configDir","path","concat","console","log","forEach","all","_chalk2","magenta","cyan","gray","configLandfill","versionSafe","_semver2","satisfies","errorString","red","_dedentJs2","_templateObject","process","exit","debug","debugMode","matchConfig","matchTemplateAndVersion","continueWithCorrectVersion","cwd","_path2","resolve","chdir","landfillConfig","templateConfig","_landfill2","install","on","error","_path","_commander","_semver","_chalk","_dedentJs","_landfill","command","description","option","action","nothing","parse","argv","slice","length","outputHelp","_ret","delim","platform","paths","env","NODE_PATH","split","_resolve2","basedir","err","res","yellow","Error","debugString","_templateObject2","blue","relative","_child_process","spawn","stdio","v","_typeof","currentPath","sep","i","pathSep","join","Promise","index","loadConfig","result","current","foundTemplate","ascendAncestry","currentConfig","getCurrentConfig","_currentConfig","sort","nextIndex","indexOf","dir","hasConfig","configFiles","configType","file","_fs2","exists","config","mergeArrays","objValue","srcValue","isArray","defineProperty","Symbol","iterator","constructor","_fs","_resolve","package.json","filePath","readFile","JSON","pkgJson","landfill","devDependencies","dependencies","getTemplatePath","templatePath","src","handleComps","answers","comps","props","prop","handleEntries","entries","entry","entryConfig","includeTemplate","encoding","skip","RegExp","destination","_templateObject3","source","opts","_fileCopy","applyTemplate","completed","landfillPath","prompt","_prompt","Prompter","init","promptArray","prompts","_classCallCheck","instance","Constructor","TypeError","questionPromise","msg","reject","question","answer","formatQuestion","def","questionString","green","bold","trim","undefined","_createClass","target","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","_readline","_readline2","this","promises","rl","createInterface","stdin","stdout","_this","promptIndex","message","getAnswers","_this2","close","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","setPrototypeOf","__proto__","pipeTemplate","templateRegex","read","write","match","pipe","TemplateStream","_ncp2","limit","transform","rename","filter","promiseMkdirp","_mkdirp2","_ncp","_mkdirp","_stream","_Transform","enc","getPrototypeOf","objectMode","contents","chunk","cb","string","Buffer","compiler","test","push","Transform","ncp","dest","callback","startCopy","started","getStats","stat","dereference","fs","lstat","running","setImmediate","stats","item","onError","name","mode","mtime","atime","isDirectory","onDir","isFile","onFile","isSymbolicLink","onLink","replace","targetPath","isWritable","copyFile","clobber","rmFile","modified","getTime","readStream","createReadStream","writeStream","createWriteStream","once","utimesSync","done","unlink","mkDir","copyDir","mkdir","readdir","items","link","readlink","resolvedPath","checkLink","basePath","makeLink","targetDest","linkPath","symlink","code","stopOnError","cback","errs","stack","skipped","finished"],"mappings":"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","file":"landfill.js","sourcesContent":["#!/usr/bin/env node\nGLOBAL.require = require;\nGLOBAL.__dirname = __dirname;\nGLOBAL.version = require('../package.json').version;\nmodule.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1);\n\tmodule.exports = __webpack_require__(2);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"babel-polyfill\");\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _templateObject = _taggedTemplateLiteral(['\\n      Expected landfill instance to be version ', '.\\n      (module found in ', ')\\n      Actual version loaded ', '\\n      Check package.json config, reinstall landfill'], ['\\n      Expected landfill instance to be version ', '.\\n      (module found in ', ')\\n      Actual version loaded ', '\\n      Check package.json config, reinstall landfill']);\n\t\n\tvar _path = __webpack_require__(3);\n\t\n\tvar _path2 = _interopRequireDefault(_path);\n\t\n\tvar _commander = __webpack_require__(4);\n\t\n\tvar _commander2 = _interopRequireDefault(_commander);\n\t\n\tvar _semver = __webpack_require__(5);\n\t\n\tvar _semver2 = _interopRequireDefault(_semver);\n\t\n\tvar _chalk = __webpack_require__(6);\n\t\n\tvar _chalk2 = _interopRequireDefault(_chalk);\n\t\n\tvar _dedentJs = __webpack_require__(7);\n\t\n\tvar _dedentJs2 = _interopRequireDefault(_dedentJs);\n\t\n\tvar _lodash = __webpack_require__(8);\n\t\n\tvar _configLoader = __webpack_require__(9);\n\t\n\tvar _landfill = __webpack_require__(13);\n\t\n\tvar _landfill2 = _interopRequireDefault(_landfill);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\t\n\t_commander2.default.version(GLOBAL.version);\n\t\n\t_commander2.default.command('list').description('List all available templates by name').option('-a, --all', 'list all available information, Name, Config Dir, Template Dir').action(function (nothing, options) {\n\t  listTemplates();\n\t});\n\t\n\t_commander2.default.command('fill <template>').description('Begin using a template <template>').option('-C, --chdir <path>', 'Change working directory').option('-d, --debug', 'Adds debuging, better source-mapping').option('-s, --version-safe <version>', 'forces use of specified version, will error out if version doesn\\'t match landfill instance version').action(function (templateName) {\n\t  configLandfill(templateName);\n\t});\n\t\n\t_commander2.default.parse(process.argv);\n\t\n\t// if no command given, show help\n\tif (!process.argv.slice(2).length) {\n\t  _commander2.default.outputHelp();\n\t}\n\t\n\tfunction listTemplates() {\n\t  var options = _commander2.default.commands[0];\n\t  (0, _configLoader.configLoader)().then(function (ancestry) {\n\t    var allTemplates = [];\n\t\n\t    var _loop = function _loop(rank) {\n\t      var ancestor = ancestry.ancestry[rank];\n\t      var templates = Object.keys(ancestor.templates).map(function (template) {\n\t        return (0, _lodash.merge)({ templateName: template, configDir: ancestor.path }, ancestor.templates[template]);\n\t      });\n\t      allTemplates = allTemplates.concat(templates);\n\t    };\n\t\n\t    for (var rank in ancestry.ancestry) {\n\t      _loop(rank);\n\t    }\n\t\n\t    console.log('List of usable Landfill templates:\\n');\n\t    allTemplates.forEach(function (template) {\n\t      if (!options.all) {\n\t        console.log('  ', _chalk2.default.magenta(template.templateName));\n\t      } else {\n\t        console.log('  ', _chalk2.default.magenta(template.templateName), _chalk2.default.cyan(template.configDir), _chalk2.default.gray(template.template));\n\t      }\n\t    });\n\t    console.log('');\n\t  });\n\t}\n\t\n\tfunction configLandfill(templateName) {\n\t  // check version safe\n\t  var options = _commander2.default.commands[1];\n\t  if (options.versionSafe && !_semver2.default.satisfies(GLOBAL.version, options.versionSafe)) {\n\t    // version safe (won't change versions) instance is wrong version\n\t    var errorString = _chalk2.default.red((0, _dedentJs2.default)(_templateObject, options.versionSafe, GLOBAL.__dirname, GLOBAL.version));\n\t    console.log(errorString);\n\t    process.exit(1);\n\t  }\n\t  // check debug flag\n\t  if (options.debug) debugMode();\n\t\n\t  // Begin loading config for landfill\n\t  (0, _configLoader.configLoader)().then(function (ancestry) {\n\t    var matchConfig = (0, _configLoader.matchTemplateAndVersion)(templateName, ancestry);\n\t\n\t    if ((0, _configLoader.continueWithCorrectVersion)(matchConfig)) {\n\t      // Using correct version of landfill for template\n\t      var cwd = _path2.default.resolve(process.cwd());\n\t\n\t      if (options.chdir) {\n\t        cwd = _path2.default.resolve(cwd, options.chdir);\n\t        if (GLOBAL.debug) console.log('Changed cwd to ' + cwd);\n\t      }\n\t\n\t      var landfillConfig = { templateName: templateName,\n\t        templateConfig: matchConfig.template,\n\t        version: GLOBAL.version,\n\t        configDir: matchConfig.configDir,\n\t        cwd: cwd\n\t      };\n\t\n\t      (0, _landfill2.default)(landfillConfig);\n\t    }\n\t  });\n\t}\n\t\n\tfunction debugMode() {\n\t  console.log('debug mode');\n\t  GLOBAL.debug = true;\n\t  // source map for stack traces\n\t  GLOBAL.require('source-map-support').install();\n\t  // use this to ensure any errors that are swallowed by promises\n\t  // are thrown\n\t  process.on('unhandledRejection', function (error) {\n\t    throw error;\n\t  });\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"path\");\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"commander\");\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"semver\");\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"chalk\");\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"dedent-js\");\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"lodash\");\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar _templateObject = _taggedTemplateLiteral(['\\n          Landfill could not resolve a local version of itself\\n          with basedir ', '\\n          using NODE_PATH(s):\\n          '], ['\\n          Landfill could not resolve a local version of itself\\n          with basedir ', '\\n          using NODE_PATH(s):\\n          ']),\n\t    _templateObject2 = _taggedTemplateLiteral(['\\n        Initialised version of landfill: ', ' does not satisfy requirement ', '\\n        Respawning with local package version at ', ''], ['\\n        Initialised version of landfill: ', ' does not satisfy requirement ', '\\n        Respawning with local package version at ', '']);\n\t\n\texports.continueWithCorrectVersion = continueWithCorrectVersion;\n\texports.configLoader = configLoader;\n\texports.matchTemplateAndVersion = matchTemplateAndVersion;\n\t\n\tvar _path = __webpack_require__(3);\n\t\n\tvar _path2 = _interopRequireDefault(_path);\n\t\n\tvar _fs = __webpack_require__(10);\n\t\n\tvar _fs2 = _interopRequireDefault(_fs);\n\t\n\tvar _lodash = __webpack_require__(8);\n\t\n\tvar _semver = __webpack_require__(5);\n\t\n\tvar _semver2 = _interopRequireDefault(_semver);\n\t\n\tvar _resolve = __webpack_require__(11);\n\t\n\tvar _resolve2 = _interopRequireDefault(_resolve);\n\t\n\tvar _child_process = __webpack_require__(12);\n\t\n\tvar _chalk = __webpack_require__(6);\n\t\n\tvar _chalk2 = _interopRequireDefault(_chalk);\n\t\n\tvar _dedentJs = __webpack_require__(7);\n\t\n\tvar _dedentJs2 = _interopRequireDefault(_dedentJs);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\t\n\t// How to load different config file types\n\t// Each option should return promises of configs\n\t// Not every config should have a version specified.\n\tvar configFiles = { 'package.json': function packageJson(filePath) {\n\t    return _fs2.default.readFile(filePath, 'utf8').then(JSON.parse).then(function (pkgJson) {\n\t      var config = void 0;\n\t      if (pkgJson.landfill) {\n\t        config = { templates: pkgJson.landfill.templates,\n\t          version: pkgJson.devDependencies.landfill || pkgJson.dependencies.landfill || false\n\t        };\n\t      } else if (pkgJson['landfill-templates']) {\n\t        config = { templates: pkgJson['landfill-templates'],\n\t          version: pkgJson.devDependencies.landfill || pkgJson.dependencies.landfill || false\n\t        };\n\t      }\n\t      return config;\n\t    });\n\t  }\n\t};\n\t\n\tfunction continueWithCorrectVersion(templateConfig) {\n\t  if (!templateConfig.version || _semver2.default.satisfies(GLOBAL.version, templateConfig.version)) {\n\t    // This version of landfill satisfies\n\t    // package.json config (or no version specified in template)\n\t    if (GLOBAL.debug) console.log('Using landfill -v', GLOBAL.version);\n\t    if (GLOBAL.debug && !templateConfig.version) console.log('no version of landfill specified by template');\n\t\n\t    // execution should continue\n\t    return true;\n\t  } else {\n\t    var _ret = function () {\n\t      // This version of landfill does\n\t      // not satisfy package.json\n\t      var delim = process.platform === 'win32' ? ';' : ':';\n\t      var paths = process.env.NODE_PATH ? process.env.NODE_PATH.split(delim) : [];\n\t      // Use node resolve alogrithm to find\n\t      // local version of landfill\n\t      (0, _resolve2.default)('landfill', { basedir: templateConfig.configDir, paths: paths }, function (err, res) {\n\t        if (err) {\n\t          // if there is an error, module cannot be found\n\t          var errorString = (0, _dedentJs2.default)(_templateObject, _chalk2.default.cyan(templateConfig.configDir));\n\t          paths.forEach(function (path) {\n\t            errorString += '\\t' + _chalk2.default.yellow(path) + '\\n';\n\t          });\n\t          throw new Error(errorString);\n\t        }\n\t\n\t        // Found matching module\n\t        if (GLOBAL.debug) {\n\t          var debugString = (0, _dedentJs2.default)(_templateObject2, _chalk2.default.blue(GLOBAL.version), _chalk2.default.blue(templateConfig.version), _chalk2.default.cyan(_path2.default.relative(templateConfig.configDir, res)));\n\t          console.log(debugString);\n\t        }\n\t\n\t        // get options passed to this landfill instance\n\t        var options = process.argv.slice(2);\n\t\n\t        // exec local landfill version-safe with same options\n\t        (0, _child_process.spawn)('node', [res, '-s', templateConfig.version].concat(options), { cwd: _path2.default.resolve(process.cwd()),\n\t          stdio: 'inherit'\n\t        });\n\t      });\n\t\n\t      // stop this process\n\t      return {\n\t        v: false\n\t      };\n\t    }();\n\t\n\t    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n\t  }\n\t}\n\t\n\tfunction configLoader() {\n\t  // Keep dictionary of parent directories and config files\n\t  var ancestry = {};\n\t\n\t  // Get cwd\n\t  var cwd = _path2.default.resolve(process.cwd());\n\t  var currentPath = _path2.default.sep; // start at disk root\n\t\n\t  // get ancestry\n\t  for (var i = 0; i < pathSep(cwd).length; i++) {\n\t    currentPath = _path2.default.join(currentPath, pathSep(cwd)[i]); // go one directory deeper\n\t    ancestry[pathSep(cwd).length - i - 1] = { path: currentPath }; // cwd should have key 0\n\t  }\n\t\n\t  return Promise.all(Object.keys(ancestry).map(function (rank, index) {\n\t    // look through cwd ancestry and check\n\t    // each ancestor for config files\n\t    var ancestor = ancestry[rank];\n\t    return loadConfig(ancestor.path).then(function (result) {\n\t      if (result) {\n\t        // ancestor directory has config\n\t        ancestor = (0, _lodash.merge)(ancestor, result);\n\t      } else {\n\t        // remove ancestor from ancestry\n\t        delete ancestry[rank];\n\t      }\n\t    });\n\t  })).then(function () {\n\t    return { ancestry: ancestry };\n\t  });\n\t}\n\t\n\tfunction matchTemplateAndVersion(templateName, ancestry) {\n\t  ancestry.current = -1;\n\t  var templateConfig = {};\n\t  var foundTemplate = false;\n\t\n\t  // find closest ancestor reference to templatename\n\t  while (ascendAncestry(ancestry)) {\n\t    var currentConfig = getCurrentConfig(ancestry);\n\t    if (currentConfig.templates[templateName]) {\n\t      templateConfig.template = currentConfig.templates[templateName];\n\t      templateConfig.configDir = currentConfig.path;\n\t      foundTemplate = true;\n\t      break;\n\t    }\n\t  }\n\t\n\t  // starting from where we found the template name\n\t  // find closest ancestor version of landfill\n\t  do {\n\t    var _currentConfig = getCurrentConfig(ancestry);\n\t    if (_currentConfig.version) {\n\t      templateConfig.version = _currentConfig.version;\n\t      break;\n\t    }\n\t  } while (ascendAncestry(ancestry));\n\t\n\t  return foundTemplate ? templateConfig : false;\n\t}\n\t\n\tfunction getCurrentConfig(ancestry) {\n\t  return ancestry.ancestry[ancestry.current];\n\t}\n\t\n\tfunction ascendAncestry(ancestry) {\n\t  var all = Object.keys(ancestry.ancestry).sort();\n\t  var nextIndex = all.indexOf(ancestry.current) + 1;\n\t  if (nextIndex < all.length) {\n\t    ancestry.current = all[nextIndex];\n\t    return all[nextIndex];\n\t  } else {\n\t    return false;\n\t  }\n\t}\n\t\n\t/**\n\t * Utils\n\t */\n\t\n\t/**\n\t * Looks for each config type, and returns\n\t * a promise which resolves with a config object\n\t * @param  {String} dir    - absolute path to search for configs in\n\t * @return {Promise|false} - resolves with config for a directory, or if there is none, returns false\n\t */\n\tfunction loadConfig(dir) {\n\t  var result = {};\n\t  var hasConfig = false;\n\t  // Prallel promises, for io with\n\t  // mutilple config files\n\t  return Promise.all(\n\t  // reduce all configs into one\n\t  Object.keys(configFiles).map(function (configType, index) {\n\t    var file = _path2.default.join(dir, configType);\n\t    // maps configTypes to promises\n\t    // that resolve configs or false\n\t    return _fs2.default.exists(file).then(function (exists) {\n\t      if (exists) {\n\t        // this directory does have a config file\n\t        hasConfig = true;\n\t        // load config type using mapped method\n\t        return configFiles[configType](file);\n\t      }\n\t      return false;\n\t    }).then(function (config) {\n\t      if (config) {\n\t        // merge each config with result\n\t        result = (0, _lodash.merge)(result, config, mergeArrays);\n\t      }\n\t    });\n\t  })\n\t  // After all configs resolve\n\t  ).then(function () {\n\t    return hasConfig ? result : false;\n\t  });\n\t}\n\t\n\tfunction mergeArrays(objValue, srcValue) {\n\t  if ((0, _lodash.isArray)(objValue)) {\n\t    return objValue.concat(srcValue);\n\t  }\n\t}\n\t\n\tfunction pathSep(p) {\n\t  return p.split(_path2.default.sep);\n\t}\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"mz/fs\");\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"resolve\");\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"child_process\");\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _templateObject = _taggedTemplateLiteral(['\\n            entry.template must be a string or an instance of RegExp.\\n            Entry ', '\\n            Template ', '\\n          '], ['\\n            entry.template must be a string or an instance of RegExp.\\n            Entry ', '\\n            Template ', '\\n          ']),\n\t    _templateObject2 = _taggedTemplateLiteral(['\\n            entry.skip must be a function, an instance of a RegExp, or false.\\n            Entry ', '\\n            Template ', '\\n          '], ['\\n            entry.skip must be a function, an instance of a RegExp, or false.\\n            Entry ', '\\n            Template ', '\\n          ']),\n\t    _templateObject3 = _taggedTemplateLiteral(['\\n            entry.destination must be a string or a function that returns a string.\\n            Entry ', '\\n            Template ', '\\n          '], ['\\n            entry.destination must be a string or a function that returns a string.\\n            Entry ', '\\n            Template ', '\\n          ']);\n\t\n\texports.default = landfill;\n\t\n\tvar _path = __webpack_require__(3);\n\t\n\tvar _path2 = _interopRequireDefault(_path);\n\t\n\tvar _prompt = __webpack_require__(14);\n\t\n\tvar _fileCopy = __webpack_require__(16);\n\t\n\tvar _chalk = __webpack_require__(6);\n\t\n\tvar _chalk2 = _interopRequireDefault(_chalk);\n\t\n\tvar _dedentJs = __webpack_require__(7);\n\t\n\tvar _dedentJs2 = _interopRequireDefault(_dedentJs);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\t\n\tfunction landfill(config) {\n\t  var cwd = config.cwd || _path2.default.resolve(process.cwd());\n\t  var templatePath = getTemplatePath();\n\t  var landfillPath = _path2.default.join(templatePath, 'landfill.js');\n\t\n\t  // load in template javascript from landfill.js file\n\t  var template = GLOBAL.require(landfillPath);\n\t\n\t  var templateName = config.templateName;\n\t  var prompt = new _prompt.Prompter();\n\t\n\t  // Begin templating\n\t  prompt.init();\n\t  // ask prompts\n\t  prompt.promptArray(template.prompts).then(function (answers) {\n\t    // Get computed props and combine with answers\n\t    var props = handleComps(answers, template.comps);\n\t\n\t    // Handle each entry\n\t    return handleEntries(props, template.entry);\n\t  }).catch(function (err) {\n\t    // catch errors\n\t    throw err;\n\t  });\n\t\n\t  /**\n\t   * Returns absolute path to template, for all valid configs\n\t   * @return {String} - path of template\n\t   */\n\t  function getTemplatePath() {\n\t    if (config.templatePath) {\n\t      // if templatePath is absolute or relatively defined\n\t      return _path2.default.resolve(cwd, config.templatePath);\n\t    } else if (config.configDir && config.templateConfig && config.templateConfig.src) {\n\t      // if configDir and templateConfig.src are defined\n\t      // (i.e. CLI is used)\n\t      return _path2.default.resolve(config.configDir, config.templateConfig.src);\n\t    } else {\n\t      throw new Error('Landfill config must contain a templatePath property.');\n\t    }\n\t  }\n\t\n\t  function handleComps(answers, comps) {\n\t    // computed props\n\t    var props = answers;\n\t    if (comps) {\n\t      for (var prop in comps) {\n\t        props[prop] = comps[prop](props, cwd);\n\t      }\n\t    }\n\t    return props;\n\t  }\n\t\n\t  /**\n\t   * Resolve all template entry properties\n\t   * Return a promise\n\t   * @param  {Object} props   - props to template with\n\t   * @param  {Object} entries - dictionary of entries from template config\n\t   * @return {Promise}        - a promise that resolves when all files\n\t   *                            copied to their new location\n\t   */\n\t  function handleEntries(props, entries) {\n\t    return Promise.all(Object.keys(entries).map(function (entry) {\n\t      var entryConfig = entries[entry];\n\t\n\t      // resolve entry config\n\t      var includeTemplate = entryConfig.template || /(js|html)$/;\n\t      var encoding = entryConfig.encoding || 'utf8';\n\t      var skip = entryConfig.skip || false;\n\t\n\t      // validate includeTemplate\n\t      if (!(includeTemplate instanceof RegExp || typeof includeTemplate === 'string')) {\n\t        throw new Error((0, _dedentJs2.default)(_templateObject, entry, templateName));\n\t      }\n\t\n\t      // validate skip\n\t      if (!(typeof skip === 'function' || skip instanceof RegExp || skip === false)) {\n\t        throw new Error((0, _dedentJs2.default)(_templateObject2, entry, templateName));\n\t      }\n\t\n\t      // Get destination for entry\n\t      var destination = void 0;\n\t\n\t      if (typeof entryConfig.destination === 'function') {\n\t        entryConfig.destination = entryConfig.destination(props, cwd);\n\t      }\n\t      if (typeof entryConfig.destination === 'string') {\n\t        destination = entryConfig.destination;\n\t      } else {\n\t        throw new Error((0, _dedentJs2.default)(_templateObject3, entry, templateName));\n\t      }\n\t\n\t      // calculate source folder for entry\n\t      var source = _path2.default.resolve(templatePath, entry);\n\t\n\t      // Config Templating\n\t      var opts = { props: props,\n\t        template: includeTemplate,\n\t        skip: skip,\n\t        encoding: encoding\n\t      };\n\t\n\t      // Apply Template\n\t      return (0, _fileCopy.applyTemplate)(source, destination, opts).then(function () {\n\t        console.log('Template ' + _chalk2.default.cyan(templateName + '/' + entry) + ', templated to ' + _chalk2.default.magenta(_path2.default.relative(cwd, destination)));\n\t      }).then(function () {\n\t        // completed entry hook\n\t        if (entryConfig.completed && typeof entryConfig.completed === 'function') {\n\t          entryConfig.completed(props, cwd, destination);\n\t        }\n\t      });\n\t    }));\n\t  }\n\t}\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Prompter = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _readline = __webpack_require__(15);\n\t\n\tvar _readline2 = _interopRequireDefault(_readline);\n\t\n\tvar _chalk = __webpack_require__(6);\n\t\n\tvar _chalk2 = _interopRequireDefault(_chalk);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * Utilities\n\t */\n\t\n\tfunction questionPromise(i, msg) {\n\t  return new Promise(function (resolve, reject) {\n\t    i.question(msg, function (answer) {\n\t      resolve(answer);\n\t    });\n\t  });\n\t}\n\t\n\tfunction formatQuestion(msg, def) {\n\t  var questionString = _chalk2.default.green('? ') + _chalk2.default.bold(msg.trim()) + ' ';\n\t  if (def) questionString += _chalk2.default.gray('(\\'' + def + '\\'): ');\n\t  return questionString;\n\t}\n\t\n\t/**\n\t * Node terminal prompt utility using latest technologies\n\t */\n\t\n\tvar Prompter = exports.Prompter = function () {\n\t  function Prompter() {\n\t    _classCallCheck(this, Prompter);\n\t\n\t    this.promises = Promise.resolve();\n\t    this.answers = {};\n\t  }\n\t\n\t  /**\n\t   * Init class, and begin readline interface\n\t   */\n\t\n\t\n\t  _createClass(Prompter, [{\n\t    key: 'init',\n\t    value: function init() {\n\t      this.rl = _readline2.default.createInterface(process.stdin, process.stdout);\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Formats and display's messages and prompts users for a single line response.\n\t     * @param  {String} key   - key answer is assigned to in answers object\n\t     * @param  {String} msg   - msg that the terminal will prompt user with\n\t     * @param  {String} [def] - [description]\n\t     * @return {Prompter}     - instance of self to allow chaining\n\t     */\n\t\n\t  }, {\n\t    key: 'prompt',\n\t    value: function prompt(key, msg, def) {\n\t      var _this = this;\n\t\n\t      this.promises = this.promises.then(function () {\n\t        var questionString = formatQuestion(msg, def);\n\t        return questionPromise(_this.rl, questionString);\n\t      }).then(function (answer) {\n\t        if (answer === '' && def) answer = def;\n\t        _this.answers[key] = answer;\n\t        return { answer: answer, key: key };\n\t      });\n\t      return this;\n\t    }\n\t  }, {\n\t    key: 'promptArray',\n\t    value: function promptArray(prompts) {\n\t      for (var promptIndex in prompts) {\n\t        var prompt = prompts[promptIndex];\n\t        var key = prompt.key;\n\t        var msg = prompt.message;\n\t        var def = prompt.default;\n\t        this.prompt(key, msg, def);\n\t      }\n\t      return this.getAnswers();\n\t    }\n\t  }, {\n\t    key: 'wait',\n\t    value: function wait() {\n\t      return this.promises;\n\t    }\n\t  }, {\n\t    key: 'getAnswers',\n\t    value: function getAnswers() {\n\t      var _this2 = this;\n\t\n\t      return this.promises.then(function () {\n\t        _this2.close();\n\t        return _this2.answers;\n\t      });\n\t    }\n\t  }, {\n\t    key: 'close',\n\t    value: function close() {\n\t      this.rl.close();\n\t    }\n\t  }]);\n\t\n\t  return Prompter;\n\t}();\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"readline\");\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\texports.applyTemplate = applyTemplate;\n\t\n\tvar _fs = __webpack_require__(10);\n\t\n\tvar _fs2 = _interopRequireDefault(_fs);\n\t\n\tvar _ncp = __webpack_require__(17);\n\t\n\tvar _ncp2 = _interopRequireDefault(_ncp);\n\t\n\tvar _mkdirp = __webpack_require__(18);\n\t\n\tvar _mkdirp2 = _interopRequireDefault(_mkdirp);\n\t\n\tvar _lodash = __webpack_require__(8);\n\t\n\tvar _stream = __webpack_require__(19);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t/**\n\t * TemplateStream is a Transform that\n\t * applies lodash templating to streams.\n\t */\n\t\n\tvar TemplateStream = function (_Transform) {\n\t  _inherits(TemplateStream, _Transform);\n\t\n\t  function TemplateStream(props, enc) {\n\t    _classCallCheck(this, TemplateStream);\n\t\n\t    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(TemplateStream).call(this, { objectMode: true }));\n\t\n\t    _this.contents = '';\n\t    _this.props = props;\n\t    _this.enc = enc;\n\t    return _this;\n\t  }\n\t\n\t  _createClass(TemplateStream, [{\n\t    key: '_transform',\n\t    value: function _transform(chunk, enc, cb) {\n\t      var string = (typeof chunk === 'undefined' ? 'undefined' : _typeof(chunk)) === _typeof('string') ? new Buffer(chunk, this.enc) : chunk;\n\t      this.contents += string;\n\t      cb();\n\t    }\n\t  }, {\n\t    key: '_flush',\n\t    value: function _flush(cb) {\n\t      var compiler = (0, _lodash.template)(this.contents);\n\t      var test = compiler(this.props);\n\t      this.push(test);\n\t      cb();\n\t    }\n\t  }]);\n\t\n\t  return TemplateStream;\n\t}(_stream.Transform);\n\t\n\tfunction pipeTemplate(props, encoding, templateRegex) {\n\t  return function (read, write) {\n\t    if (read.path.match(templateRegex)) {\n\t      read.pipe(new TemplateStream(props, encoding)).pipe(write);\n\t    } else {\n\t      read.pipe(write);\n\t    }\n\t  };\n\t}\n\t\n\tfunction applyTemplate(source, destination, opts) {\n\t  _ncp2.default.limit = 16;\n\t  // resolve options\n\t  var props = opts.props || {};\n\t  var encoding = opts.encoding || 'utf8';\n\t  var skip = opts.skip;\n\t  var templateRegex = opts.template;\n\t\n\t  var options = { transform: pipeTemplate(props, encoding, templateRegex),\n\t    rename: function rename(target) {\n\t      return (0, _lodash.template)(target)(props);\n\t    }\n\t  };\n\t\n\t  // if skip regex, or function defined add to\n\t  // ncp options\n\t  if (skip) options.filter = skip;\n\t\n\t  return _fs2.default.exists(destination).then(function (exists) {\n\t    if (exists) return;\n\t    return promiseMkdirp(destination);\n\t  }).then(function () {\n\t    return new Promise(function (resolve, reject) {\n\t      (0, _ncp2.default)(source, destination, options, function (err) {\n\t        if (err) reject(err);\n\t        resolve(true);\n\t      });\n\t    });\n\t  });\n\t}\n\t\n\tfunction promiseMkdirp(dir) {\n\t  return new Promise(function (resolve, reject) {\n\t    (0, _mkdirp2.default)(dir, function (err) {\n\t      if (err) reject(err);\n\t      resolve(true);\n\t    });\n\t  });\n\t}\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/*\n\t * This is a versy slightly modified version of ncp-node by Charlie McConnell\n\t * an open source library from:\n\t * https://github.com/AvianFlu/ncp/\n\t *\n\t * It exposes the ability to rename files & dirs as you copy them\n\t * Below is a copy of the License\n\t *\n\t  # MIT License\n\t\n\t  ###Copyright (C) 2011 by Charlie McConnell\n\t\n\t  Permission is hereby granted, free of charge, to any person obtaining a copy\n\t  of this software and associated documentation files (the \"Software\"), to deal\n\t  in the Software without restriction, including without limitation the rights\n\t  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\t  copies of the Software, and to permit persons to whom the Software is\n\t  furnished to do so, subject to the following conditions:\n\t\n\t  The above copyright notice and this permission notice shall be included in\n\t  all copies or substantial portions of the Software.\n\t\n\t  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\t  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\t  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\t  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\t  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\t  THE SOFTWARE.\n\t */\n\t\n\t/*eslint-disable*/\n\tvar fs = GLOBAL.require('fs'),\n\t    path = GLOBAL.require('path');\n\t\n\tmodule.exports = ncp;\n\tncp.ncp = ncp;\n\t\n\tfunction ncp(source, dest, options, callback) {\n\t  var cback = callback;\n\t\n\t  if (!callback) {\n\t    cback = options;\n\t    options = {};\n\t  }\n\t\n\t  var basePath = process.cwd(),\n\t      currentPath = path.resolve(basePath, source),\n\t      targetPath = path.resolve(basePath, dest),\n\t      filter = options.filter,\n\t      rename = options.rename,\n\t      transform = options.transform,\n\t      clobber = options.clobber !== false,\n\t      modified = options.modified,\n\t      dereference = options.dereference,\n\t      errs = null,\n\t      started = 0,\n\t      finished = 0,\n\t      running = 0,\n\t      limit = options.limit || ncp.limit || 16;\n\t\n\t  limit = limit < 1 ? 1 : limit > 512 ? 512 : limit;\n\t\n\t  startCopy(currentPath);\n\t\n\t  function startCopy(source) {\n\t    started++;\n\t    if (filter) {\n\t      if (filter instanceof RegExp) {\n\t        if (!filter.test(source)) {\n\t          return cb(true);\n\t        }\n\t      } else if (typeof filter === 'function') {\n\t        if (!filter(source)) {\n\t          return cb(true);\n\t        }\n\t      }\n\t    }\n\t    return getStats(source);\n\t  }\n\t\n\t  function getStats(source) {\n\t    var stat = dereference ? fs.stat : fs.lstat;\n\t    if (running >= limit) {\n\t      return setImmediate(function () {\n\t        getStats(source);\n\t      });\n\t    }\n\t    running++;\n\t    stat(source, function (err, stats) {\n\t      var item = {};\n\t      if (err) {\n\t        return onError(err);\n\t      }\n\t\n\t      // We need to get the mode from the stats object and preserve it.\n\t      item.name = source;\n\t      item.mode = stats.mode;\n\t      item.mtime = stats.mtime; //modified time\n\t      item.atime = stats.atime; //access time\n\t\n\t      if (stats.isDirectory()) {\n\t        return onDir(item);\n\t      } else if (stats.isFile()) {\n\t        return onFile(item);\n\t      } else if (stats.isSymbolicLink()) {\n\t        // Symlinks don't really need to know about the mode.\n\t        return onLink(source);\n\t      }\n\t    });\n\t  }\n\t\n\t  function onFile(file) {\n\t    var target = file.name.replace(currentPath, targetPath);\n\t\n\t    if (rename) {\n\t      target = rename(target);\n\t    }\n\t    isWritable(target, function (writable) {\n\t      if (writable) {\n\t        return copyFile(file, target);\n\t      }\n\t      if (clobber) {\n\t        rmFile(target, function () {\n\t          copyFile(file, target);\n\t        });\n\t      }\n\t      if (modified) {\n\t        var stat = dereference ? fs.stat : fs.lstat;\n\t        stat(target, function (err, stats) {\n\t          //if souce modified time greater to target modified time copy file\n\t          if (file.mtime.getTime() > stats.mtime.getTime()) copyFile(file, target);else return cb();\n\t        });\n\t      } else {\n\t        return cb();\n\t      }\n\t    });\n\t  }\n\t\n\t  function copyFile(file, target) {\n\t    var readStream = fs.createReadStream(file.name),\n\t        writeStream = fs.createWriteStream(target, { mode: file.mode });\n\t\n\t    readStream.on('error', onError);\n\t    writeStream.on('error', onError);\n\t\n\t    if (transform) {\n\t      transform(readStream, writeStream, file);\n\t    } else {\n\t      writeStream.on('open', function () {\n\t        readStream.pipe(writeStream);\n\t      });\n\t    }\n\t    writeStream.once('finish', function () {\n\t      if (modified) {\n\t        //target file modified date sync.\n\t        fs.utimesSync(target, file.atime, file.mtime);\n\t        cb();\n\t      } else cb();\n\t    });\n\t  }\n\t\n\t  function rmFile(file, done) {\n\t    fs.unlink(file, function (err) {\n\t      if (err) {\n\t        return onError(err);\n\t      }\n\t      return done();\n\t    });\n\t  }\n\t\n\t  function onDir(dir) {\n\t    var target = dir.name.replace(currentPath, targetPath);\n\t    if (rename) {\n\t      target = rename(target);\n\t    }\n\t    isWritable(target, function (writable) {\n\t      if (writable) {\n\t        return mkDir(dir, target);\n\t      }\n\t      copyDir(dir.name);\n\t    });\n\t  }\n\t\n\t  function mkDir(dir, target) {\n\t    fs.mkdir(target, dir.mode, function (err) {\n\t      if (err) {\n\t        return onError(err);\n\t      }\n\t      copyDir(dir.name);\n\t    });\n\t  }\n\t\n\t  function copyDir(dir) {\n\t    fs.readdir(dir, function (err, items) {\n\t      if (err) {\n\t        return onError(err);\n\t      }\n\t      items.forEach(function (item) {\n\t        startCopy(path.join(dir, item));\n\t      });\n\t      return cb();\n\t    });\n\t  }\n\t\n\t  function onLink(link) {\n\t    var target = link.replace(currentPath, targetPath);\n\t    fs.readlink(link, function (err, resolvedPath) {\n\t      if (err) {\n\t        return onError(err);\n\t      }\n\t      checkLink(resolvedPath, target);\n\t    });\n\t  }\n\t\n\t  function checkLink(resolvedPath, target) {\n\t    if (dereference) {\n\t      resolvedPath = path.resolve(basePath, resolvedPath);\n\t    }\n\t    isWritable(target, function (writable) {\n\t      if (writable) {\n\t        return makeLink(resolvedPath, target);\n\t      }\n\t      fs.readlink(target, function (err, targetDest) {\n\t        if (err) {\n\t          return onError(err);\n\t        }\n\t        if (dereference) {\n\t          targetDest = path.resolve(basePath, targetDest);\n\t        }\n\t        if (targetDest === resolvedPath) {\n\t          return cb();\n\t        }\n\t        return rmFile(target, function () {\n\t          makeLink(resolvedPath, target);\n\t        });\n\t      });\n\t    });\n\t  }\n\t\n\t  function makeLink(linkPath, target) {\n\t    fs.symlink(linkPath, target, function (err) {\n\t      if (err) {\n\t        return onError(err);\n\t      }\n\t      return cb();\n\t    });\n\t  }\n\t\n\t  function isWritable(path, done) {\n\t    fs.lstat(path, function (err) {\n\t      if (err) {\n\t        if (err.code === 'ENOENT') return done(true);\n\t        return done(false);\n\t      }\n\t      return done(false);\n\t    });\n\t  }\n\t\n\t  function onError(err) {\n\t    if (options.stopOnError) {\n\t      return cback(err);\n\t    } else if (!errs && options.errs) {\n\t      errs = fs.createWriteStream(options.errs);\n\t    } else if (!errs) {\n\t      errs = [];\n\t    }\n\t    if (typeof errs.write === 'undefined') {\n\t      errs.push(err);\n\t    } else {\n\t      errs.write(err.stack + '\\n\\n');\n\t    }\n\t    return cb();\n\t  }\n\t\n\t  function cb(skipped) {\n\t    if (!skipped) running--;\n\t    finished++;\n\t    if (started === finished && running === 0) {\n\t      if (cback !== undefined) {\n\t        return errs ? cback(errs) : cback(null);\n\t      }\n\t    }\n\t  }\n\t}\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"mkdirp\");\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"stream\");\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** landfill.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap c9240960ac4a66e8dc56\n **/","module.exports = require(\"babel-polyfill\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"babel-polyfill\"\n ** module id = 1\n ** module chunks = 0\n **/","import path from 'path'\n\nimport program from 'commander'\nimport semver from 'semver'\nimport chalk from 'chalk'\nimport dedent from 'dedent-js'\nimport { merge } from 'lodash'\n\nimport\n  { configLoader\n  , matchTemplateAndVersion\n  , continueWithCorrectVersion\n  } from './lib/configLoader'\n\nimport landfill from './landfill'\n\nprogram\n  .version(GLOBAL.version)\n\nprogram\n  .command('list')\n  .description('List all available templates by name')\n  .option('-a, --all', 'list all available information, Name, Config Dir, Template Dir')\n  .action(function (nothing, options) {\n    listTemplates()\n  })\n\nprogram\n  .command('fill <template>')\n  .description('Begin using a template <template>')\n  .option('-C, --chdir <path>', 'Change working directory')\n  .option('-d, --debug', 'Adds debuging, better source-mapping')\n  .option('-s, --version-safe <version>',\n    'forces use of specified version, will error out if version doesn\\'t match landfill instance version')\n  .action(function (templateName) {\n    configLandfill(templateName)\n  })\n\nprogram.parse(process.argv)\n\n// if no command given, show help\nif (!process.argv.slice(2).length) {\n  program.outputHelp()\n}\n\nfunction listTemplates () {\n  let options = program.commands[0]\n  configLoader().then(ancestry => {\n    let allTemplates = []\n    for (let rank in ancestry.ancestry) {\n      let ancestor = ancestry.ancestry[rank]\n      let templates = Object.keys(ancestor.templates).map(template => {\n        return merge({ templateName: template, configDir: ancestor.path }, ancestor.templates[template])\n      })\n      allTemplates = allTemplates.concat(templates)\n    }\n\n    console.log('List of usable Landfill templates:\\n')\n    allTemplates.forEach(template => {\n      if (!options.all) {\n        console.log('  ', chalk.magenta(template.templateName))\n      } else {\n        console.log('  ', chalk.magenta(template.templateName), chalk.cyan(template.configDir), chalk.gray(template.template))\n      }\n    })\n    console.log('')\n  })\n}\n\nfunction configLandfill (templateName) {\n  // check version safe\n  let options = program.commands[1]\n  if (options.versionSafe &&\n    !semver.satisfies(GLOBAL.version, options.versionSafe)) {\n    // version safe (won't change versions) instance is wrong version\n    let errorString =\n      chalk.red(dedent `\n      Expected landfill instance to be version ${options.versionSafe}.\n      (module found in ${GLOBAL.__dirname})\n      Actual version loaded ${GLOBAL.version}\n      Check package.json config, reinstall landfill`)\n    console.log(errorString)\n    process.exit(1)\n  }\n  // check debug flag\n  if (options.debug) debugMode()\n\n  // Begin loading config for landfill\n  configLoader().then(ancestry => {\n    let matchConfig = matchTemplateAndVersion(templateName, ancestry)\n\n    if (continueWithCorrectVersion(matchConfig)) {\n      // Using correct version of landfill for template\n      let cwd = path.resolve(process.cwd())\n\n      if (options.chdir) {\n        cwd = path.resolve(cwd, options.chdir)\n        if (GLOBAL.debug) console.log(`Changed cwd to ${cwd}`)\n      }\n\n      const landfillConfig =\n        { templateName: templateName\n        , templateConfig: matchConfig.template\n        , version: GLOBAL.version\n        , configDir: matchConfig.configDir\n        , cwd: cwd\n        }\n\n      landfill(landfillConfig)\n    }\n  })\n}\n\nfunction debugMode () {\n  console.log('debug mode')\n  GLOBAL.debug = true\n  // source map for stack traces\n  GLOBAL.require('source-map-support').install()\n  // use this to ensure any errors that are swallowed by promises\n  // are thrown\n  process.on('unhandledRejection', function (error) {\n    throw error\n  })\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/cli.js\n **/","module.exports = require(\"path\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"path\"\n ** module id = 3\n ** module chunks = 0\n **/","module.exports = require(\"commander\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"commander\"\n ** module id = 4\n ** module chunks = 0\n **/","module.exports = require(\"semver\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"semver\"\n ** module id = 5\n ** module chunks = 0\n **/","module.exports = require(\"chalk\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"chalk\"\n ** module id = 6\n ** module chunks = 0\n **/","module.exports = require(\"dedent-js\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"dedent-js\"\n ** module id = 7\n ** module chunks = 0\n **/","module.exports = require(\"lodash\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"lodash\"\n ** module id = 8\n ** module chunks = 0\n **/","import path from 'path'\nimport fs from 'mz/fs'\nimport { merge, isArray } from 'lodash'\nimport semver from 'semver'\nimport resolve from 'resolve'\nimport { spawn } from 'child_process'\nimport chalk from 'chalk'\nimport dedent from 'dedent-js'\n\n// How to load different config file types\n// Each option should return promises of configs\n// Not every config should have a version specified.\nlet configFiles =\n  { 'package.json':\n      function (filePath) {\n        return fs.readFile(filePath, 'utf8')\n          .then(JSON.parse)\n          .then(pkgJson => {\n            let config\n            if (pkgJson.landfill) {\n              config =\n                { templates: pkgJson.landfill.templates\n                , version:\n                    pkgJson.devDependencies.landfill ||\n                    pkgJson.dependencies.landfill ||\n                    false\n                }\n            } else if (pkgJson['landfill-templates']) {\n              config =\n                { templates: pkgJson['landfill-templates']\n                , version:\n                    pkgJson.devDependencies.landfill ||\n                    pkgJson.dependencies.landfill ||\n                    false\n                }\n            }\n            return config\n          })\n      }\n  }\n\nexport function continueWithCorrectVersion (templateConfig) {\n  if (!templateConfig.version || semver.satisfies(GLOBAL.version, templateConfig.version)) {\n    // This version of landfill satisfies\n    // package.json config (or no version specified in template)\n    if (GLOBAL.debug) console.log('Using landfill -v', GLOBAL.version)\n    if (GLOBAL.debug && !templateConfig.version) console.log('no version of landfill specified by template')\n\n    // execution should continue\n    return true\n  } else {\n    // This version of landfill does\n    // not satisfy package.json\n    let delim = (process.platform === 'win32' ? ';' : ':')\n    let paths = (process.env.NODE_PATH ? process.env.NODE_PATH.split(delim) : [])\n    // Use node resolve alogrithm to find\n    // local version of landfill\n    resolve('landfill', { basedir: templateConfig.configDir, paths: paths }, (err, res) => {\n      if (err) {\n        // if there is an error, module cannot be found\n        let errorString = dedent `\n          Landfill could not resolve a local version of itself\n          with basedir ${chalk.cyan(templateConfig.configDir)}\n          using NODE_PATH(s):\n          `\n        paths.forEach((path) => {\n          errorString += `\\t${chalk.yellow(path)}\\n`\n        })\n        throw new Error(errorString)\n      }\n\n      // Found matching module\n      if (GLOBAL.debug) {\n        let debugString = dedent `\n        Initialised version of landfill: ${chalk.blue(GLOBAL.version)} does not satisfy requirement ${chalk.blue(templateConfig.version)}\n        Respawning with local package version at ${chalk.cyan(path.relative(templateConfig.configDir, res))}`\n        console.log(debugString)\n      }\n\n      // get options passed to this landfill instance\n      let options = process.argv.slice(2)\n\n      // exec local landfill version-safe with same options\n      spawn('node'\n        , [res, '-s', templateConfig.version].concat(options)\n        , { cwd: path.resolve(process.cwd())\n          , stdio: 'inherit'\n          }\n        )\n    })\n\n    // stop this process\n    return false\n  }\n}\n\nexport function configLoader () {\n  // Keep dictionary of parent directories and config files\n  let ancestry = {}\n\n  // Get cwd\n  let cwd = path.resolve(process.cwd())\n  let currentPath = path.sep // start at disk root\n\n  // get ancestry\n  for (var i = 0; i < pathSep(cwd).length; i++) {\n    currentPath = path.join(currentPath, pathSep(cwd)[i]) // go one directory deeper\n    ancestry[pathSep(cwd).length - i - 1] = { path: currentPath } // cwd should have key 0\n  }\n\n  return Promise.all(\n    Object.keys(ancestry).map((rank, index) => {\n      // look through cwd ancestry and check\n      // each ancestor for config files\n      let ancestor = ancestry[rank]\n      return loadConfig(ancestor.path)\n        .then(result => {\n          if (result) {\n            // ancestor directory has config\n            ancestor = merge(ancestor, result)\n          } else {\n            // remove ancestor from ancestry\n            delete ancestry[rank]\n          }\n        })\n    })\n  ).then(() => {\n    return { ancestry: ancestry }\n  })\n}\n\nexport function matchTemplateAndVersion (templateName, ancestry) {\n  ancestry.current = -1\n  let templateConfig = {}\n  let foundTemplate = false\n\n  // find closest ancestor reference to templatename\n  while (ascendAncestry(ancestry)) {\n    let currentConfig = getCurrentConfig(ancestry)\n    if (currentConfig.templates[templateName]) {\n      templateConfig.template = currentConfig.templates[templateName]\n      templateConfig.configDir = currentConfig.path\n      foundTemplate = true\n      break\n    }\n  }\n\n  // starting from where we found the template name\n  // find closest ancestor version of landfill\n  do {\n    let currentConfig = getCurrentConfig(ancestry)\n    if (currentConfig.version) {\n      templateConfig.version = currentConfig.version\n      break\n    }\n  } while (ascendAncestry(ancestry))\n\n  return (foundTemplate) ? templateConfig : false\n}\n\nfunction getCurrentConfig (ancestry) {\n  return ancestry.ancestry[ancestry.current]\n}\n\nfunction ascendAncestry (ancestry) {\n  let all = Object.keys(ancestry.ancestry).sort()\n  let nextIndex = all.indexOf(ancestry.current) + 1\n  if (nextIndex < all.length) {\n    ancestry.current = all[nextIndex]\n    return all[nextIndex]\n  } else {\n    return false\n  }\n}\n\n/**\n * Utils\n */\n\n/**\n * Looks for each config type, and returns\n * a promise which resolves with a config object\n * @param  {String} dir    - absolute path to search for configs in\n * @return {Promise|false} - resolves with config for a directory, or if there is none, returns false\n */\nfunction loadConfig (dir) {\n  let result = {}\n  let hasConfig = false\n  // Prallel promises, for io with\n  // mutilple config files\n  return Promise.all(\n    // reduce all configs into one\n    Object.keys(configFiles)\n      .map((configType, index) => {\n        let file = path.join(dir, configType)\n        // maps configTypes to promises\n        // that resolve configs or false\n        return fs.exists(file).then(exists => {\n          if (exists) {\n            // this directory does have a config file\n            hasConfig = true\n            // load config type using mapped method\n            return configFiles[configType](file)\n          }\n          return false\n        }).then(config => {\n          if (config) {\n            // merge each config with result\n            result = merge(result, config, mergeArrays)\n          }\n        })\n      })\n  // After all configs resolve\n  ).then(() => {\n    return (hasConfig) ? result : false\n  })\n}\n\nfunction mergeArrays (objValue, srcValue) {\n  if (isArray(objValue)) {\n    return objValue.concat(srcValue)\n  }\n}\n\nfunction pathSep (p) {\n  return p.split(path.sep)\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/configLoader.js\n **/","module.exports = require(\"mz/fs\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"mz/fs\"\n ** module id = 10\n ** module chunks = 0\n **/","module.exports = require(\"resolve\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"resolve\"\n ** module id = 11\n ** module chunks = 0\n **/","module.exports = require(\"child_process\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"child_process\"\n ** module id = 12\n ** module chunks = 0\n **/","import path from 'path'\n\nimport { Prompter } from './lib/prompt'\nimport { applyTemplate } from './lib/fileCopy.js'\nimport chalk from 'chalk'\nimport dedent from 'dedent-js'\n\nexport default function landfill (config) {\n  let cwd = config.cwd || path.resolve(process.cwd())\n  let templatePath = getTemplatePath()\n  let landfillPath = path.join(templatePath, 'landfill.js')\n\n  // load in template javascript from landfill.js file\n  let template = GLOBAL.require(landfillPath)\n\n  const templateName = config.templateName\n  const prompt = new Prompter()\n\n  // Begin templating\n  prompt.init()\n  // ask prompts\n  prompt\n    .promptArray(template.prompts)\n    .then(answers => {\n      // Get computed props and combine with answers\n      let props = handleComps(answers, template.comps)\n\n      // Handle each entry\n      return handleEntries(props, template.entry)\n    }).catch((err) => {\n      // catch errors\n      throw err\n    })\n\n  /**\n   * Returns absolute path to template, for all valid configs\n   * @return {String} - path of template\n   */\n  function getTemplatePath () {\n    if (config.templatePath) {\n      // if templatePath is absolute or relatively defined\n      return path.resolve(cwd, config.templatePath)\n    } else if (config.configDir &&\n                config.templateConfig &&\n                config.templateConfig.src) {\n      // if configDir and templateConfig.src are defined\n      // (i.e. CLI is used)\n      return path.resolve(config.configDir, config.templateConfig.src)\n    } else {\n      throw new Error('Landfill config must contain a templatePath property.')\n    }\n  }\n\n  function handleComps (answers, comps) {\n    // computed props\n    let props = answers\n    if (comps) {\n      for (let prop in comps) {\n        props[prop] = comps[prop](props, cwd)\n      }\n    }\n    return props\n  }\n\n  /**\n   * Resolve all template entry properties\n   * Return a promise\n   * @param  {Object} props   - props to template with\n   * @param  {Object} entries - dictionary of entries from template config\n   * @return {Promise}        - a promise that resolves when all files\n   *                            copied to their new location\n   */\n  function handleEntries (props, entries) {\n    return Promise.all(\n      Object.keys(entries).map((entry) => {\n        let entryConfig = entries[entry]\n\n        // resolve entry config\n        let includeTemplate = entryConfig.template || /(js|html)$/\n        let encoding = entryConfig.encoding || 'utf8'\n        let skip = entryConfig.skip || false\n\n        // validate includeTemplate\n        if (!(includeTemplate instanceof RegExp || typeof includeTemplate === 'string')) {\n          throw new Error(dedent `\n            entry.template must be a string or an instance of RegExp.\n            Entry ${entry}\n            Template ${templateName}\n          `)\n        }\n\n        // validate skip\n        if (!(typeof skip === 'function' || skip instanceof RegExp || skip === false)) {\n          throw new Error(dedent `\n            entry.skip must be a function, an instance of a RegExp, or false.\n            Entry ${entry}\n            Template ${templateName}\n          `)\n        }\n\n        // Get destination for entry\n        let destination\n\n        if (typeof entryConfig.destination === 'function') {\n          entryConfig.destination = entryConfig.destination(props, cwd)\n        }\n        if (typeof entryConfig.destination === 'string') {\n          destination = entryConfig.destination\n        } else {\n          throw new Error(dedent `\n            entry.destination must be a string or a function that returns a string.\n            Entry ${entry}\n            Template ${templateName}\n          `)\n        }\n\n        // calculate source folder for entry\n        let source = path.resolve(templatePath, entry)\n\n        // Config Templating\n        let opts =\n          { props: props\n          , template: includeTemplate\n          , skip: skip\n          , encoding: encoding\n          }\n\n        // Apply Template\n        return applyTemplate(source, destination, opts)\n          .then(() => {\n            console.log(`Template ${chalk.cyan(templateName + '/' + entry)}, templated to ${chalk.magenta(path.relative(cwd, destination))}`)\n          }).then(() => {\n            // completed entry hook\n            if (entryConfig.completed && typeof entryConfig.completed === 'function') {\n              entryConfig.completed(props, cwd, destination)\n            }\n          })\n      })\n    )\n  }\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/landfill.js\n **/","import readline from 'readline'\nimport chalk from 'chalk'\n\n/**\n * Utilities\n */\n\nfunction questionPromise (i, msg) {\n  return new Promise((resolve, reject) => {\n    i.question(msg, answer => {\n      resolve(answer)\n    })\n  })\n}\n\nfunction formatQuestion (msg, def) {\n  let questionString = chalk.green('? ') + chalk.bold(msg.trim()) + ' '\n  if (def) questionString += chalk.gray('(\\'' + def + '\\'): ')\n  return questionString\n}\n\n/**\n * Node terminal prompt utility using latest technologies\n */\n\nexport class Prompter {\n  constructor () {\n    this.promises = Promise.resolve()\n    this.answers = {}\n  }\n\n  /**\n   * Init class, and begin readline interface\n   */\n  init () {\n    this.rl = readline.createInterface(process.stdin, process.stdout)\n    return this\n  }\n\n  /**\n   * Formats and display's messages and prompts users for a single line response.\n   * @param  {String} key   - key answer is assigned to in answers object\n   * @param  {String} msg   - msg that the terminal will prompt user with\n   * @param  {String} [def] - [description]\n   * @return {Prompter}     - instance of self to allow chaining\n   */\n  prompt (key, msg, def) {\n    this.promises = this.promises.then(() => {\n      let questionString = formatQuestion(msg, def)\n      return questionPromise(this.rl, questionString)\n    })\n    .then(answer => {\n      if (answer === '' && def) answer = def\n      this.answers[key] = answer\n      return { answer: answer, key: key }\n    })\n    return this\n  }\n\n  promptArray (prompts) {\n    for (let promptIndex in prompts) {\n      let prompt = prompts[promptIndex]\n      let key = prompt.key\n      let msg = prompt.message\n      let def = prompt.default\n      this.prompt(key, msg, def)\n    }\n    return this.getAnswers()\n  }\n\n  wait () {\n    return this.promises\n  }\n\n  getAnswers () {\n    return this.promises.then(() => {\n      this.close()\n      return this.answers\n    })\n  }\n\n  close () {\n    this.rl.close()\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/prompt.js\n **/","module.exports = require(\"readline\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"readline\"\n ** module id = 15\n ** module chunks = 0\n **/","import fs from 'mz/fs'\nimport ncp from './ncp'\nimport mkdirp from 'mkdirp'\nimport { template } from 'lodash'\nimport { Transform } from 'stream'\n\n/**\n * TemplateStream is a Transform that\n * applies lodash templating to streams.\n */\nclass TemplateStream extends Transform {\n  constructor (props, enc) {\n    super({ objectMode: true })\n    this.contents = ''\n    this.props = props\n    this.enc = enc\n  }\n\n  _transform (chunk, enc, cb) {\n    let string = (typeof chunk === typeof 'string')\n      ? new Buffer(chunk, this.enc)\n      : chunk\n    this.contents += string\n    cb()\n  }\n\n  _flush (cb) {\n    let compiler = template(this.contents)\n    let test = compiler(this.props)\n    this.push(test)\n    cb()\n  }\n}\n\nfunction pipeTemplate (props, encoding, templateRegex) {\n  return function (read, write) {\n    if (read.path.match(templateRegex)) {\n      read\n        .pipe(new TemplateStream(props, encoding))\n        .pipe(write)\n    } else {\n      read.pipe(write)\n    }\n  }\n}\n\nexport function applyTemplate (source, destination, opts) {\n  ncp.limit = 16\n  // resolve options\n  let props = opts.props || {}\n  let encoding = opts.encoding || 'utf8'\n  let skip = opts.skip\n  let templateRegex = opts.template\n\n  let options =\n    { transform: pipeTemplate(props, encoding, templateRegex)\n    , rename: function (target) { return template(target)(props) }\n    }\n\n  // if skip regex, or function defined add to\n  // ncp options\n  if (skip) options.filter = skip\n\n  return fs.exists(destination)\n    .then((exists) => {\n      if (exists) return\n      return promiseMkdirp(destination)\n    }).then(() => {\n      return new Promise((resolve, reject) => {\n        ncp(source, destination, options, function (err) {\n          if (err) reject(err)\n          resolve(true)\n        })\n      })\n    })\n}\n\nfunction promiseMkdirp (dir) {\n  return new Promise((resolve, reject) => {\n    mkdirp(dir, (err) => {\n      if (err) reject(err)\n      resolve(true)\n    })\n  })\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/fileCopy.js\n **/","/*\n * This is a versy slightly modified version of ncp-node by Charlie McConnell\n * an open source library from:\n * https://github.com/AvianFlu/ncp/\n *\n * It exposes the ability to rename files & dirs as you copy them\n * Below is a copy of the License\n *\n  # MIT License\n\n  ###Copyright (C) 2011 by Charlie McConnell\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.\n */\n\n/*eslint-disable*/\nvar fs = GLOBAL.require('fs'),\n    path = GLOBAL.require('path');\n\nmodule.exports = ncp;\nncp.ncp = ncp;\n\nfunction ncp (source, dest, options, callback) {\n  var cback = callback;\n\n  if (!callback) {\n    cback = options;\n    options = {};\n  }\n\n  var basePath = process.cwd(),\n      currentPath = path.resolve(basePath, source),\n      targetPath = path.resolve(basePath, dest),\n      filter = options.filter,\n      rename = options.rename,\n      transform = options.transform,\n      clobber = options.clobber !== false,\n      modified = options.modified,\n      dereference = options.dereference,\n      errs = null,\n      started = 0,\n      finished = 0,\n      running = 0,\n      limit = options.limit || ncp.limit || 16;\n\n  limit = (limit < 1) ? 1 : (limit > 512) ? 512 : limit;\n\n  startCopy(currentPath);\n  \n  function startCopy(source) {\n    started++;\n    if (filter) {\n      if (filter instanceof RegExp) {\n        if (!filter.test(source)) {\n          return cb(true);\n        }\n      }\n      else if (typeof filter === 'function') {\n        if (!filter(source)) {\n          return cb(true);\n        }\n      }\n    }\n    return getStats(source);\n  }\n\n  function getStats(source) {\n    var stat = dereference ? fs.stat : fs.lstat;\n    if (running >= limit) {\n      return setImmediate(function () {\n        getStats(source);\n      });\n    }\n    running++;\n    stat(source, function (err, stats) {\n      var item = {};\n      if (err) {\n        return onError(err);\n      }\n\n      // We need to get the mode from the stats object and preserve it.\n      item.name = source;\n      item.mode = stats.mode;\n      item.mtime = stats.mtime; //modified time\n      item.atime = stats.atime; //access time\n\n      if (stats.isDirectory()) {\n        return onDir(item);\n      }\n      else if (stats.isFile()) {\n        return onFile(item);\n      }\n      else if (stats.isSymbolicLink()) {\n        // Symlinks don't really need to know about the mode.\n        return onLink(source);\n      }\n    });\n  }\n\n  function onFile(file) {\n    var target = file.name.replace(currentPath, targetPath);\n\n    if(rename) {\n      target =  rename(target);\n    }\n    isWritable(target, function (writable) {\n      if (writable) {\n        return copyFile(file, target);\n      }\n      if(clobber) {\n        rmFile(target, function () {\n          copyFile(file, target);\n        });\n      }\n      if (modified) {\n        var stat = dereference ? fs.stat : fs.lstat;\n        stat(target, function(err, stats) {\n            //if souce modified time greater to target modified time copy file\n            if (file.mtime.getTime()>stats.mtime.getTime())\n                copyFile(file, target);\n            else return cb();\n        });\n      }\n      else {\n        return cb();\n      }\n    });\n  }\n\n  function copyFile(file, target) {\n    var readStream = fs.createReadStream(file.name),\n        writeStream = fs.createWriteStream(target, { mode: file.mode });\n    \n    readStream.on('error', onError);\n    writeStream.on('error', onError);\n    \n    if(transform) {\n      transform(readStream, writeStream, file);\n    } else {\n      writeStream.on('open', function() {\n        readStream.pipe(writeStream);\n      });\n    }\n    writeStream.once('finish', function() {\n        if (modified) {\n            //target file modified date sync.\n            fs.utimesSync(target, file.atime, file.mtime);\n            cb();\n        }\n        else cb();\n    });\n  }\n\n  function rmFile(file, done) {\n    fs.unlink(file, function (err) {\n      if (err) {\n        return onError(err);\n      }\n      return done();\n    });\n  }\n\n  function onDir(dir) {\n    var target = dir.name.replace(currentPath, targetPath);\n    if(rename) {\n      target =  rename(target);\n    }\n    isWritable(target, function (writable) {\n      if (writable) {\n        return mkDir(dir, target);\n      }\n      copyDir(dir.name);\n    });\n  }\n\n  function mkDir(dir, target) {\n    fs.mkdir(target, dir.mode, function (err) {\n      if (err) {\n        return onError(err);\n      }\n      copyDir(dir.name);\n    });\n  }\n\n  function copyDir(dir) {\n    fs.readdir(dir, function (err, items) {\n      if (err) {\n        return onError(err);\n      }\n      items.forEach(function (item) {\n        startCopy(path.join(dir, item));\n      });\n      return cb();\n    });\n  }\n\n  function onLink(link) {\n    var target = link.replace(currentPath, targetPath);\n    fs.readlink(link, function (err, resolvedPath) {\n      if (err) {\n        return onError(err);\n      }\n      checkLink(resolvedPath, target);\n    });\n  }\n\n  function checkLink(resolvedPath, target) {\n    if (dereference) {\n      resolvedPath = path.resolve(basePath, resolvedPath);\n    }\n    isWritable(target, function (writable) {\n      if (writable) {\n        return makeLink(resolvedPath, target);\n      }\n      fs.readlink(target, function (err, targetDest) {\n        if (err) {\n          return onError(err);\n        }\n        if (dereference) {\n          targetDest = path.resolve(basePath, targetDest);\n        }\n        if (targetDest === resolvedPath) {\n          return cb();\n        }\n        return rmFile(target, function () {\n          makeLink(resolvedPath, target);\n        });\n      });\n    });\n  }\n\n  function makeLink(linkPath, target) {\n    fs.symlink(linkPath, target, function (err) {\n      if (err) {\n        return onError(err);\n      }\n      return cb();\n    });\n  }\n\n  function isWritable(path, done) {\n    fs.lstat(path, function (err) {\n      if (err) {\n        if (err.code === 'ENOENT') return done(true);\n        return done(false);\n      }\n      return done(false);\n    });\n  }\n\n  function onError(err) {\n    if (options.stopOnError) {\n      return cback(err);\n    }\n    else if (!errs && options.errs) {\n      errs = fs.createWriteStream(options.errs);\n    }\n    else if (!errs) {\n      errs = [];\n    }\n    if (typeof errs.write === 'undefined') {\n      errs.push(err);\n    }\n    else { \n      errs.write(err.stack + '\\n\\n');\n    }\n    return cb();\n  }\n\n  function cb(skipped) {\n    if (!skipped) running--;\n    finished++;\n    if ((started === finished) && (running === 0)) {\n      if (cback !== undefined ) {\n        return errs ? cback(errs) : cback(null);\n      }\n    }\n  }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/ncp.js\n **/","module.exports = require(\"mkdirp\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"mkdirp\"\n ** module id = 18\n ** module chunks = 0\n **/","module.exports = require(\"stream\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"stream\"\n ** module id = 19\n ** module chunks = 0\n **/"],"sourceRoot":""}